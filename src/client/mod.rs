mod generators;
mod ctx;
mod generator;

use std::path::Path;
use std::process::Command;
use teo_result::Result;
use teo_runtime::config::client::{Client, ClientLanguage};
use teo_runtime::namespace::Namespace;
use generators::*;
use crate::client::ctx::Ctx;
use crate::client::generator::Generator;
use crate::utils::file::FileUtil;
use crate::utils::message::green_message;

pub async fn generate(main_namespace: &Namespace, client: &Client) -> Result<()> {
    match client.provider {
        ClientLanguage::TypeScript(_) => {
            let ctx = Ctx::new(client, main_namespace);
            let generator = ts::gen::TSGenerator::new();
            gen(generator, &ctx).await
        }
        ClientLanguage::Swift => {
            let ctx = Ctx::new(client, main_namespace);
            let generator = swift::gen::SwiftGenerator::new();
            gen(generator, &ctx).await
        }
        ClientLanguage::Kotlin => {
            let ctx = Ctx::new(client, main_namespace);
            let generator = kotlin::gen::KotlinGenerator::new();
            gen(generator, &ctx).await
        }
        ClientLanguage::CSharp => {
            let ctx = Ctx::new(client, main_namespace);
            let generator = csharp::gen::CSharpGenerator::new();
            gen(generator, &ctx).await
        }
        ClientLanguage::Dart => {
            let ctx = Ctx::new(client, main_namespace);
            let generator = dart::gen::DartGenerator::new();
            gen(generator, &ctx).await
        }
    }?;
    std::process::exit(0);
}

async fn gen<T: Generator>(client_generator: T, ctx: &Ctx<'_>) -> Result<()> {
    let dest_dir = std::env::current_dir()?.join(&ctx.conf.dest);
    let package = ctx.conf.package;
    let git_commit = ctx.conf.git_commit;
    let mut module_dest = dest_dir.clone();
    let should_git_init = !dest_dir.exists();
    if package {
        let package_generator = FileUtil::new(dest_dir.clone());
        client_generator.generate_package_files(ctx, &package_generator).await?;
        module_dest.push(Path::new(client_generator.module_directory_in_package(ctx.conf).as_str()));
    } else {
        let package_generator = FileUtil::new(dest_dir.clone());
        client_generator.update_parent_package_files(ctx, &package_generator).await?;
    }
    let module_generator = FileUtil::new(module_dest);
    client_generator.generate_module_files(ctx, &module_generator).await?;
    client_generator.generate_main(ctx, &module_generator).await?;
    if git_commit && package {
        std::env::set_current_dir(&dest_dir).unwrap();
        if should_git_init {
            // git init
            Command::new("git")
                .arg("init")
                .output().unwrap();
            green_message("Run", "`git init`".to_string());
        }
        // git add -A
        Command::new("git")
            .arg("add")
            .arg("-A")
            .output().unwrap();
        green_message("Run", "`git add -A`".to_string());
        Command::new("git")
            .arg("commit")
            .arg("-m")
            .arg("generated by teo")
            .output().unwrap();
        // git commit
        green_message("Run", "`git commit -m 'generated by teo'`".to_string());
    }
    Ok(())
}
